package [[group_name]].[[project_name]].application.service

import arrow.core.left
import arrow.core.right
import [[group_name]].[[project_name]].domain.model.Customer
import [[group_name]].[[project_name]].domain.model.CustomerId
import [[group_name]].[[project_name]].domain.model.CustomerRepository
import [[group_name]].[[project_name]].domain.model.DomainError
import [[group_name]].[[project_name]].domain.model.Email
import [[group_name]].[[project_name]].domain.model.FullName
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.just
import io.mockk.mockk
import io.mockk.runs
import io.mockk.verify
import java.util.UUID

private val CUSTOMER_ID = UUID.randomUUID()

class SignUpCustomerServiceShould : StringSpec({

    "sign up a customer successfully" {
        val repository = mockk<CustomerRepository>()
        val customer = Customer(
            CustomerId(CUSTOMER_ID),
            FullName("Fabrizio Di Napoli"),
            Email("some.email@example.org")
        )
        val request = SignUpCustomerRequest(
            id = CUSTOMER_ID,
            name = "Fabrizio",
            surname = "Di Napoli",
            email = "some.email@example.org",
        )
        every { repository.save(customer) } just runs

        val response = SignUpCustomerService(repository).invoke(request)

        response shouldBe SignUpCustomerResponse(id = CUSTOMER_ID).right()
    }

    "return an error in case of customer data not passing business rules" {
        val repository = mockk<CustomerRepository>()
        val request = SignUpCustomerRequest(
            id = CUSTOMER_ID,
            name = "Fabrizio",
            surname = "",
            email = "some.email@example.org",
        )

        val response = SignUpCustomerService(repository).invoke(request)

        response shouldBe DomainError("Surname cannot be empty").left()
        verify(exactly = 0) { repository.save(any()) }
    }
})
